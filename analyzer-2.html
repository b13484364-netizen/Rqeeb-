<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÙƒØ§Ø´Ù Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø§Ù„Ù…Ø²ÙˆØ±Ø© - ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/4b9ba14b0f.js" crossorigin="anonymous"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .upload-area {
            border: 2px dashed #d1d5db;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
        }
        .upload-area.dragover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.1);
        }
        .analysis-card {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
            border: 1px solid rgba(93, 92, 222, 0.2);
        }
        .progress-container {
            background: linear-gradient(90deg, #5D5CDE 0%, #9333EA 100%);
        }
        .result-excellent { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
        .result-good { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
        .result-poor { background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); }
        .metric-card {
            transition: all 0.3s ease;
            border: 1px solid rgba(93, 92, 222, 0.1);
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(93, 92, 222, 0.15);
        }
        .comparison-images {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }
        .image-preview {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .image-preview img {
            width: 100%;
            height: auto;
            display: block;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">
                <i class="fas fa-shield-alt mr-3"></i>
                ÙƒØ§Ø´Ù Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø§Ù„Ù…Ø²ÙˆØ±Ø©
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-lg">
                ØªØ­Ù„ÙŠÙ„ Ù…ØªØ·ÙˆØ± Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ØªØ²ÙˆÙŠØ± ÙˆØ§Ù„ØªÙ„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
            </p>
        </div>

        <!-- Upload Section -->
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-upload mr-3 text-primary"></i>
                Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„
            </h2>
            
            <div id="uploadArea" class="upload-area rounded-lg p-8 text-center cursor-pointer bg-gray-50 dark:bg-gray-700">
                <div id="uploadContent">
                    <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                    <p class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">
                        Ø§Ø³Ø­Ø¨ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±
                    </p>
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                        ÙŠØ¯Ø¹Ù…: JPG, PNG, GIF (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)
                    </p>
                    <input type="file" id="imageFile" accept="image/*" class="hidden">
                </div>
                <div id="imagePreview" class="hidden">
                    <img id="previewImg" class="max-w-full h-64 object-contain mx-auto rounded-lg">
                    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">Ø§Ù„ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„</p>
                </div>
            </div>

            <button id="analyzeBtn" class="w-full mt-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:shadow-lg transform hover:scale-105 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i class="fas fa-search mr-2"></i>
                Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
            </button>
        </div>

        <!-- Progress Section -->
        <div id="progressSection" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold mb-4 flex items-center">
                <i class="fas fa-cog fa-spin mr-3 text-primary"></i>
                Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„...
            </h3>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 mb-4">
                <div id="progressBar" class="progress-container h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-center text-gray-600 dark:text-gray-400 font-medium">0% - Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¶ÙŠØ±...</p>
        </div>

        <!-- Results Section -->
        <div id="resultSection" class="hidden">
            <!-- Overall Score -->
            <div id="overallScore" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-4 flex items-center">
                    <i class="fas fa-chart-line mr-3 text-primary"></i>
                    Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
                </h2>
                <div id="scoreDisplay" class="text-center p-6 rounded-lg text-white font-bold text-3xl">
                    <!-- Score will be inserted here -->
                </div>
                <div id="scoreInterpretation" class="mt-4 p-4 rounded-lg">
                    <!-- Interpretation will be inserted here -->
                </div>
            </div>

            <!-- Detailed Analysis -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-microscope mr-3 text-primary"></i>
                    ØªØ­Ù„ÙŠÙ„ Ù…ÙØµÙ„ Ù„Ù„Ù…Ù‚Ø§ÙŠÙŠØ³
                </h2>
                <div id="detailedMetrics" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Metrics will be inserted here -->
                </div>
            </div>

            <!-- Visual Comparison -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-eye mr-3 text-primary"></i>
                    Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¨ØµØ±ÙŠØ© ÙˆØ§Ù„ÙØ±ÙˆÙ‚Ø§Øª
                </h2>
                <div id="visualComparison">
                    <!-- Visual comparison will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dark mode handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Upload handling
        const uploadArea = document.getElementById('uploadArea');
        const imageFile = document.getElementById('imageFile');
        const uploadContent = document.getElementById('uploadContent');
        const imagePreview = document.getElementById('imagePreview');
        const previewImg = document.getElementById('previewImg');
        const analyzeBtn = document.getElementById('analyzeBtn');

        uploadArea.addEventListener('click', () => imageFile.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        imageFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        function handleFileSelect(file) {
            if (!file.type.startsWith('image/')) {
                showCustomAlert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù ØµÙˆØ±Ø© ØµØ­ÙŠØ­');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                showCustomAlert('Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                previewImg.src = e.target.result;
                uploadContent.classList.add('hidden');
                imagePreview.classList.remove('hidden');
                analyzeBtn.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        analyzeBtn.addEventListener('click', startSingleImageAnalysis);

        async function startSingleImageAnalysis() {
            const file = imageFile.files[0];
            if (!file) {
                showCustomAlert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹');
                return;
            }

            // Show progress section
            document.getElementById('progressSection').classList.remove('hidden');
            document.getElementById('resultSection').classList.add('hidden');
            
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            try {
                updateProgress(10, 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©...');
                const imageCanvas = await loadImageToCanvas(file);

                updateProgress(20, 'Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†Ø·Ù‚ØªÙŠÙ† Ù„Ù„ØªØ­Ù„ÙŠÙ„...');
                const regions = splitCanvas(imageCanvas);
                const [originalRegion, suspectRegion] = regions;

                const region1 = convertToGrayscale(originalRegion);
                const region2 = convertToGrayscale(suspectRegion);

                updateProgress(35, 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù…Ø³ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø±Ø´Ø­ Gabor...');
                const textureScore = analyzeGaborTexture(region1, region2);

                updateProgress(50, 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø·ÙŠÙÙŠ...');
                const freqScore = analyzeFrequency(region1, region2);

                updateProgress(65, 'ØªØ­Ù„ÙŠÙ„ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„Ù†Ù…Ø·...');
                const colorScore = analyzeColorSimilarity(originalRegion, suspectRegion);

                updateProgress(75, 'ÙƒØ´Ù Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡ ÙˆØ§Ù„ØªØ´ÙˆÙŠØ´...');
                const noiseScore = analyzeNoise(region1, region2);

                updateProgress(85, 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ù ÙˆØ§Ù„ØªØ¨Ø§ÙŠÙ†...');
                const edgeScore = analyzeEdgeConsistency(region1, region2);

                updateProgress(90, 'Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø¨ÙƒØ³Ù„Ø§Øª...');
                const pixelDiff = simplePixelDiff(region1, region2);
                const pixelScore = Math.max(0, 100 - (pixelDiff / 50) * 100);

                updateProgress(95, 'Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ...');
                const diffImageDataURL = createDiffImage(region1, region2);
                const heatmapDataURL = createHeatmap(region1, region2);

                // Calculate weighted final score
                const weights = {
                    texture: 0.20,
                    frequency: 0.20,
                    color: 0.20,
                    noise: 0.15,
                    edge: 0.15,
                    pixel: 0.10
                };

                const score = (
                    (textureScore * weights.texture) +
                    (freqScore * weights.frequency) +
                    (colorScore * weights.color) +
                    (noiseScore * weights.noise) +
                    (edgeScore * weights.edge) +
                    (pixelScore * weights.pixel)
                );

                updateProgress(100, `ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ - Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${score.toFixed(1)}%`);

                // Display results
                setTimeout(() => {
                    displayResults({
                        score,
                        metrics: {
                            texture: textureScore,
                            frequency: freqScore,
                            color: colorScore,
                            noise: noiseScore,
                            edge: edgeScore,
                            pixel: pixelScore
                        },
                        images: {
                            original: originalRegion.toDataURL(),
                            suspect: suspectRegion.toDataURL(),
                            diff: diffImageDataURL,
                            heatmap: heatmapDataURL
                        }
                    });
                }, 1000);

            } catch (error) {
                console.error('Error during analysis:', error);
                showCustomAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„: ' + error.message);
            }
        }

        function updateProgress(percentage, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${percentage}% - ${text}`;
        }

        async function loadImageToCanvas(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas);
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        function splitCanvas(canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const halfWidth = Math.floor(width / 2);

            // Create two canvases for left and right halves
            const leftCanvas = document.createElement('canvas');
            const rightCanvas = document.createElement('canvas');
            
            leftCanvas.width = halfWidth;
            leftCanvas.height = height;
            rightCanvas.width = halfWidth;
            rightCanvas.height = height;

            const leftCtx = leftCanvas.getContext('2d');
            const rightCtx = rightCanvas.getContext('2d');
            const sourceCtx = canvas.getContext('2d');

            // Copy left half
            leftCtx.drawImage(canvas, 0, 0, halfWidth, height, 0, 0, halfWidth, height);
            
            // Copy right half
            rightCtx.drawImage(canvas, halfWidth, 0, halfWidth, height, 0, 0, halfWidth, height);

            return [leftCanvas, rightCanvas];
        }

        function convertToGrayscale(canvas) {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            const ctx = newCanvas.getContext('2d');
            
            ctx.drawImage(canvas, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = gray;     // R
                data[i + 1] = gray; // G
                data[i + 2] = gray; // B
            }

            ctx.putImageData(imageData, 0, 0);
            return newCanvas;
        }

        function analyzeGaborTexture(canvas1, canvas2) {
            // Simplified Gabor-like texture analysis
            const data1 = canvas1.getContext('2d').getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height).data;

            let textureScore1 = 0, textureScore2 = 0;
            const step = 4;

            for (let i = step; i < data1.length - step; i += 4) {
                const current1 = data1[i];
                const next1 = data1[i + step];
                const prev1 = data1[i - step];
                textureScore1 += Math.abs(current1 - next1) + Math.abs(current1 - prev1);

                const current2 = data2[i];
                const next2 = data2[i + step];
                const prev2 = data2[i - step];
                textureScore2 += Math.abs(current2 - next2) + Math.abs(current2 - prev2);
            }

            const similarity = 1 - Math.abs(textureScore1 - textureScore2) / Math.max(textureScore1, textureScore2, 1);
            return Math.max(0, Math.min(100, similarity * 100));
        }

        function analyzeFrequency(canvas1, canvas2) {
            // Simplified frequency domain analysis using gradient magnitude
            const data1 = canvas1.getContext('2d').getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height).data;

            let freq1 = 0, freq2 = 0;
            const width = canvas1.width;

            for (let y = 1; y < canvas1.height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Calculate gradient for canvas1
                    const gx1 = data1[idx + 4] - data1[idx - 4]; // right - left
                    const gy1 = data1[idx + width * 4] - data1[idx - width * 4]; // down - up
                    freq1 += Math.sqrt(gx1 * gx1 + gy1 * gy1);

                    // Calculate gradient for canvas2
                    const gx2 = data2[idx + 4] - data2[idx - 4];
                    const gy2 = data2[idx + width * 4] - data2[idx - width * 4];
                    freq2 += Math.sqrt(gx2 * gx2 + gy2 * gy2);
                }
            }

            const similarity = 1 - Math.abs(freq1 - freq2) / Math.max(freq1, freq2, 1);
            return Math.max(0, Math.min(100, similarity * 100));
        }

        function analyzeColorSimilarity(canvas1, canvas2) {
            const data1 = canvas1.getContext('2d').getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height).data;

            let totalDiff = 0;
            for (let i = 0; i < data1.length; i += 4) {
                const rDiff = Math.abs(data1[i] - data2[i]);
                const gDiff = Math.abs(data1[i + 1] - data2[i + 1]);
                const bDiff = Math.abs(data1[i + 2] - data2[i + 2]);
                totalDiff += (rDiff + gDiff + bDiff) / 3;
            }

            const avgDiff = totalDiff / (data1.length / 4);
            const similarity = Math.max(0, 100 - (avgDiff / 255) * 100);
            return similarity;
        }

        function analyzeNoise(canvas1, canvas2) {
            // Analyze noise patterns using local variance
            const data1 = canvas1.getContext('2d').getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height).data;

            let noise1 = 0, noise2 = 0;
            const width = canvas1.width;
            const windowSize = 3;

            for (let y = windowSize; y < canvas1.height - windowSize; y++) {
                for (let x = windowSize; x < width - windowSize; x++) {
                    let sum1 = 0, sum2 = 0, count = 0;

                    // Calculate local mean
                    for (let dy = -windowSize; dy <= windowSize; dy++) {
                        for (let dx = -windowSize; dx <= windowSize; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            sum1 += data1[idx];
                            sum2 += data2[idx];
                            count++;
                        }
                    }

                    const mean1 = sum1 / count;
                    const mean2 = sum2 / count;

                    // Calculate local variance (noise indicator)
                    let variance1 = 0, variance2 = 0;
                    for (let dy = -windowSize; dy <= windowSize; dy++) {
                        for (let dx = -windowSize; dx <= windowSize; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            variance1 += Math.pow(data1[idx] - mean1, 2);
                            variance2 += Math.pow(data2[idx] - mean2, 2);
                        }
                    }

                    noise1 += variance1 / count;
                    noise2 += variance2 / count;
                }
            }

            const similarity = 1 - Math.abs(noise1 - noise2) / Math.max(noise1, noise2, 1);
            return Math.max(0, Math.min(100, similarity * 100));
        }

        function analyzeEdgeConsistency(canvas1, canvas2) {
            // Sobel edge detection comparison
            const data1 = canvas1.getContext('2d').getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height).data;

            const width = canvas1.width;
            let edgeSum1 = 0, edgeSum2 = 0;

            for (let y = 1; y < canvas1.height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;

                    // Sobel operators
                    const gx1 = -data1[idx - width * 4 - 4] + data1[idx - width * 4 + 4] +
                               -2 * data1[idx - 4] + 2 * data1[idx + 4] +
                               -data1[idx + width * 4 - 4] + data1[idx + width * 4 + 4];

                    const gy1 = -data1[idx - width * 4 - 4] - 2 * data1[idx - width * 4] - data1[idx - width * 4 + 4] +
                                data1[idx + width * 4 - 4] + 2 * data1[idx + width * 4] + data1[idx + width * 4 + 4];

                    edgeSum1 += Math.sqrt(gx1 * gx1 + gy1 * gy1);

                    const gx2 = -data2[idx - width * 4 - 4] + data2[idx - width * 4 + 4] +
                               -2 * data2[idx - 4] + 2 * data2[idx + 4] +
                               -data2[idx + width * 4 - 4] + data2[idx + width * 4 + 4];

                    const gy2 = -data2[idx - width * 4 - 4] - 2 * data2[idx - width * 4] - data2[idx - width * 4 + 4] +
                                data2[idx + width * 4 - 4] + 2 * data2[idx + width * 4] + data2[idx + width * 4 + 4];

                    edgeSum2 += Math.sqrt(gx2 * gx2 + gy2 * gy2);
                }
            }

            const similarity = 1 - Math.abs(edgeSum1 - edgeSum2) / Math.max(edgeSum1, edgeSum2, 1);
            return Math.max(0, Math.min(100, similarity * 100));
        }

        function simplePixelDiff(canvas1, canvas2) {
            const ctx1 = canvas1.getContext("2d");
            const ctx2 = canvas2.getContext("2d");
            const data1 = ctx1.getImageData(0, 0, canvas1.width, canvas1.height).data;
            const data2 = ctx2.getImageData(0, 0, canvas2.width, canvas2.height).data;

            let totalDiff = 0;
            for (let i = 0; i < data1.length; i += 4) {
                const gray1 = (data1[i] + data1[i + 1] + data1[i + 2]) / 3;
                const gray2 = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
                totalDiff += Math.abs(gray1 - gray2);
            }

            return totalDiff / (data1.length / 4);
        }

        function createDiffImage(canvas1, canvas2) {
            const width = canvas1.width;
            const height = canvas1.height;

            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = width;
            outputCanvas.height = height;

            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            const outCtx = outputCanvas.getContext('2d');

            const data1 = ctx1.getImageData(0, 0, width, height).data;
            const data2 = ctx2.getImageData(0, 0, width, height).data;

            const output = outCtx.createImageData(width, height);

            for (let i = 0; i < data1.length; i += 4) {
                const gray1 = (data1[i] + data1[i + 1] + data1[i + 2]) / 3;
                const gray2 = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
                const diff = Math.abs(gray1 - gray2);

                if (diff > 30) {
                    output.data[i] = 255;     // R
                    output.data[i + 1] = 0;   // G
                    output.data[i + 2] = 0;   // B
                    output.data[i + 3] = 255; // A
                } else {
                    const intensity = Math.min(255, gray1 + diff);
                    output.data[i] = intensity;
                    output.data[i + 1] = intensity;
                    output.data[i + 2] = intensity;
                    output.data[i + 3] = 255;
                }
            }

            outCtx.putImageData(output, 0, 0);
            return outputCanvas.toDataURL();
        }

        function createHeatmap(canvas1, canvas2) {
            const width = canvas1.width;
            const height = canvas1.height;

            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = width;
            outputCanvas.height = height;

            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            const outCtx = outputCanvas.getContext('2d');

            const data1 = ctx1.getImageData(0, 0, width, height).data;
            const data2 = ctx2.getImageData(0, 0, width, height).data;

            const output = outCtx.createImageData(width, height);

            for (let i = 0; i < data1.length; i += 4) {
                const gray1 = (data1[i] + data1[i + 1] + data1[i + 2]) / 3;
                const gray2 = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
                const diff = Math.abs(gray1 - gray2) / 255;

                // Create heat map colors (blue to red)
                if (diff < 0.2) {
                    output.data[i] = 0;         // R
                    output.data[i + 1] = 0;     // G
                    output.data[i + 2] = 255;   // B
                } else if (diff < 0.5) {
                    output.data[i] = 255 * diff * 2;  // R
                    output.data[i + 1] = 255;          // G
                    output.data[i + 2] = 0;            // B
                } else {
                    output.data[i] = 255;       // R
                    output.data[i + 1] = 0;     // G
                    output.data[i + 2] = 0;     // B
                }
                output.data[i + 3] = 200; // Semi-transparent
            }

            outCtx.putImageData(output, 0, 0);
            return outputCanvas.toDataURL();
        }

        function displayResults(results) {
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('resultSection').classList.remove('hidden');

            const { score, metrics, images } = results;

            // Display overall score
            const scoreDisplay = document.getElementById('scoreDisplay');
            const scoreInterpretation = document.getElementById('scoreInterpretation');

            let scoreClass, interpretation, icon;
            if (score >= 75) {
                scoreClass = 'result-excellent';
                interpretation = 'âœ… Ø§Ù„Ù…Ø³ØªÙ†Ø¯ ÙŠØ¨Ø¯Ùˆ Ø£ØµÙ„ÙŠØ§Ù‹ ÙˆØ³Ù„ÙŠÙ…Ø§Ù‹. Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯Ù„Ø§Ø¦Ù„ ÙˆØ§Ø¶Ø­Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªØ²ÙˆÙŠØ±.';
                icon = 'fas fa-check-circle';
            } else if (score >= 50) {
                scoreClass = 'result-good';
                interpretation = 'âš ï¸ Ù‡Ù†Ø§Ùƒ Ø¨Ø¹Ø¶ Ø§Ù„Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø§Ù„Ø·ÙÙŠÙØ©. ÙŠÙÙ†ØµØ­ Ø¨Ø§Ù„ÙØ­Øµ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ.';
                icon = 'fas fa-exclamation-triangle';
            } else {
                scoreClass = 'result-poor';
                interpretation = 'ğŸš¨ Ø§Ø­ØªÙ…Ø§Ù„ Ø§Ù„ØªØ²ÙˆÙŠØ± Ù…Ø±ØªÙØ¹! ØªÙˆØ¬Ø¯ Ø§Ø®ØªÙ„Ø§ÙØ§Øª ÙƒØ¨ÙŠØ±Ø© ØªØ´ÙŠØ± Ø¥Ù„Ù‰ ØªÙ„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ†Ø¯.';
                icon = 'fas fa-times-circle';
            }

            scoreDisplay.className = `text-center p-6 rounded-lg text-white font-bold text-3xl ${scoreClass}`;
            scoreDisplay.innerHTML = `
                <i class="${icon} mr-3"></i>
                ${score.toFixed(1)}%
            `;

            scoreInterpretation.className = `mt-4 p-4 rounded-lg border-r-4 ${score >= 75 ? 'bg-green-50 dark:bg-green-900/20 border-green-500' : score >= 50 ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-500' : 'bg-red-50 dark:bg-red-900/20 border-red-500'}`;
            scoreInterpretation.innerHTML = interpretation;

            // Display detailed metrics
            const metricsContainer = document.getElementById('detailedMetrics');
            const metricLabels = {
                texture: { name: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù…Ø³', icon: 'fas fa-texture' },
                frequency: { name: 'Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ', icon: 'fas fa-wave-square' },
                color: { name: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù„ÙˆØ§Ù†', icon: 'fas fa-palette' },
                noise: { name: 'ÙƒØ´Ù Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡', icon: 'fas fa-volume-up' },
                edge: { name: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ù', icon: 'fas fa-vector-square' },
                pixel: { name: 'Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª', icon: 'fas fa-th' }
            };

            metricsContainer.innerHTML = Object.entries(metrics).map(([key, value]) => {
                const label = metricLabels[key];
                const percentage = value.toFixed(1);
                const colorClass = value >= 75 ? 'text-green-600' : value >= 50 ? 'text-yellow-600' : 'text-red-600';
                
                return `
                    <div class="metric-card bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center">
                                <i class="${label.icon} text-primary mr-2"></i>
                                <span class="font-medium">${label.name}</span>
                            </div>
                            <span class="font-bold ${colorClass}">${percentage}%</span>
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
                            <div class="bg-gradient-to-r from-primary to-purple-600 h-2 rounded-full transition-all duration-1000" style="width: ${value}%"></div>
                        </div>
                    </div>
                `;
            }).join('');

            // Display visual comparison
            const visualComparison = document.getElementById('visualComparison');
            visualComparison.innerHTML = `
                <div class="comparison-images">
                    <div class="image-preview">
                        <img src="${images.original}" alt="Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©">
                        <div class="image-label">Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ (Ù…Ø±Ø¬Ø¹)</div>
                    </div>
                    <div class="image-preview">
                        <img src="${images.suspect}" alt="Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø´ÙƒÙˆÙƒ ÙÙŠÙ‡Ø§">
                        <div class="image-label">Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© (Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©)</div>
                    </div>
                    <div class="image-preview">
                        <img src="${images.diff}" alt="ØµÙˆØ±Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª">
                        <div class="image-label">Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª (Ø£Ø­Ù…Ø± = Ø§Ø®ØªÙ„Ø§Ù)</div>
                    </div>
                </div>
                <div class="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-700">
                    <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                        <i class="fas fa-info-circle mr-2"></i>
                        ØªÙØ³ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨ØµØ±ÙŠØ©
                    </h4>
                    <ul class="text-blue-700 dark:text-blue-300 text-sm space-y-1">
                        <li>â€¢ <strong>Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø­Ù…Ø±Ø§Ø¡:</strong> ØªØ´ÙŠØ± Ø¥Ù„Ù‰ Ø§Ø®ØªÙ„Ø§ÙØ§Øª ÙˆØ§Ø¶Ø­Ø© Ø¨ÙŠÙ† Ø§Ù„Ù…Ù†Ø·Ù‚ØªÙŠÙ†</li>
                        <li>â€¢ <strong>Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠØ©:</strong> ØªØ´ÙŠØ± Ø¥Ù„Ù‰ ØªØ·Ø§Ø¨Ù‚ Ø£Ùˆ Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø·ÙÙŠÙØ©</li>
                        <li>â€¢ <strong>ÙƒØ«Ø±Ø© Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø­Ù…Ø±Ø§Ø¡:</strong> Ù‚Ø¯ ØªØ¯Ù„ Ø¹Ù„Ù‰ ØªÙ„Ø§Ø¹Ø¨ Ø£Ùˆ ØªØ²ÙˆÙŠØ±</li>
                        <li>â€¢ <strong>Ø§Ù„Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©:</strong> Ù‚Ø¯ ØªÙ†ØªØ¬ Ø¹Ù† Ø§Ø®ØªÙ„Ø§Ù Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ù„Ù„Ù…Ø³ØªÙ†Ø¯</li>
                    </ul>
                </div>
            `;

            // Scroll to results
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }

        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <div class="flex items-center mb-4">
                        <i class="fas fa-exclamation-triangle text-yellow-500 text-xl mr-3"></i>
                        <h3 class="font-bold text-lg">ØªÙ†Ø¨ÙŠÙ‡</h3>
                    </div>
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-purple-600 rounded transition-colors" onclick="this.closest('.fixed').remove()">Ø­Ø³Ù†Ø§Ù‹</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>
